---
description: Core principles and architecture for Hyperscape plugin development
globs: packages/plugin-eliza/**/*.ts
alwaysApply: true
---

# Hyperscape Plugin - Core Principles

> Core architectural principles for developing the `@hyperscape/plugin-eliza` package.

## Core Principles

### 1. Follow ElizaOS Plugin Architecture
- **ALWAYS** reference [ElizaOS Plugin Architecture](https://docs.elizaos.ai/plugins/architecture) before implementing features
- **ALWAYS** follow the Plugin interface structure: `name`, `description`, `services`, `providers`, `actions`, `events`
- **NEVER** deviate from ElizaOS component patterns without justification
- **ALWAYS** use `@elizaos/core` types and interfaces

### 2. Hyperscape Integration Patterns
- **ALWAYS** use `@hyperscape/shared` types (`World`, `Player`, `Entity`, `System`)
- **NEVER** create duplicate type definitions - import from `@hyperscape/shared`
- **ALWAYS** maintain separation: Plugin code ↔ Hyperscape world systems
- **ALWAYS** use WebSocket for real-time communication (via `HyperscapeService`)

### 3. Service-First Architecture
- **ALWAYS** access Hyperscape world through `HyperscapeService` (never direct world access)
- **ALWAYS** check `service.isConnected()` before executing actions
- **ALWAYS** handle reconnection logic in the service, not in actions/providers
- **NEVER** store world state in actions/providers - use service cache

## Plugin Structure

Reference the main plugin export: @packages/plugin-eliza/src/index.ts

```
src/
├── index.ts              # Plugin export (services, providers, actions, events)
├── service.ts            # Main HyperscapeService (WebSocket, world connection)
├── services/             # Service implementations
├── providers/            # Context providers (gameState, inventory, etc.)
├── actions/              # Executable game commands
├── managers/             # Specialized managers (behavior, build, emote, etc.)
├── systems/              # Hyperscape world systems (actions, avatar, environment)
├── clients/              # WebSocket client implementations
├── config/               # Configuration constants
├── templates/            # Prompt templates for agent behavior
├── types/                # TypeScript type definitions
├── utils/                # Utility functions
├── testing/              # Visual testing framework
├── __tests__/            # Unit and E2E tests
└── public/               # Static assets (emotes, avatars, etc.)
```

## Component Registration Order

**CRITICAL**: Components MUST register in this exact order:

1. **Database Adapter** (if provided)
2. **Actions** ← Hyperscape actions register here
3. **Evaluators**
4. **Providers** ← Hyperscape providers register here
5. **Models**
6. **Routes**
7. **Events**
8. **Services** (delayed if runtime not initialized)

**Why Order Matters:**
- Actions may depend on database adapter
- Providers may use actions for context
- Services initialize before components use them
- Breaking order causes initialization failures

**Rules:**
- ✅ **ALWAYS** register components in this exact order
- ✅ **ALWAYS** register services last (they may be delayed)
- ✅ **NEVER** change component registration order
- ✅ **NEVER** assume services are initialized immediately

## Service Access Pattern

**ALWAYS** check service availability before use:

```typescript
const service = runtime.getService<HyperscapeService>('hyperscapeService');
if (!service || !service.isConnected()) {
  return { success: false, error: new Error('Service not available') };
}

const playerEntity = service.getPlayerEntity();
const world = service.getWorld();
```

## Type Safety

- **ALWAYS** use `import type` for type-only imports
- **ALWAYS** import from `@elizaos/core` for ElizaOS types
- **ALWAYS** import from `@hyperscape/shared` for Hyperscape types
- **NEVER** use `any` - use proper types or `unknown` with type guards
- **ALWAYS** define plugin-specific types in `src/types/`

## Error Handling

- **ALWAYS** wrap async operations in try-catch
- **ALWAYS** log errors with context (`logger.error`, `logger.warn`)
- **ALWAYS** notify user via callback on errors
- **ALWAYS** return proper error structure in ActionResult
- **NEVER** throw unhandled errors from actions/providers

## Forbidden Patterns

❌ **NEVER**:
- Create duplicate type definitions (use `@hyperscape/shared`)
- Access world directly (always use service)
- Store state in actions/providers (use service cache)
- Throw unhandled errors (always catch and return error)
- Use `any` types (use proper types or `unknown`)
- Skip error handling (always handle gracefully)
- Create circular dependencies
- Hardcode game logic (use config/constants)

## Required Patterns

✅ **ALWAYS**:
- Check service availability before use
- Validate inputs with Zod or type guards
- Handle errors gracefully with callbacks
- Log important operations
- Document exported functions
- Write tests for new features
- Use proper TypeScript types
- Follow ElizaOS plugin architecture

---
alwaysApply: true
---
# TypeScript Strong Typing Rules

## Core Principles

### 1. NO `any` or `unknown` Types
- **NEVER** use `any` - it's banned by ESLint and defeats type safety
- Avoid `unknown` unless absolutely necessary for type guards
- Instead of `any`, use specific types, union types, or generic constraints
- For dynamic objects, create proper type definitions

### 2. Classes Over Interfaces
- **Prefer classes** for type definitions when possible
- Classes provide runtime type information and better instanceof checks
- Use direct type aliases instead of interfaces for simple types
- Example:
  ```typescript
  // ❌ Avoid
  interface Player {
    id: string;
    health: number;
  }
  
  // ✅ Prefer
  class Player {
    constructor(
      public id: string,
      public health: number
    ) {}
  }
  
  // ✅ Or for simple types
  type Player = {
    id: string;
    health: number;
  }
  ```

### 3. Share Types Across Modules
- Import and reuse types from [types/core.ts](mdc:packages/hyperscape/src/rpg/types/core.ts) and other type definition files
- Don't recreate types that already exist - this helps catch structural issues
- Use type imports to avoid circular dependencies: `import type { TypeName } from './types'`

### 4. Avoid Property Checks on Polymorphic Objects
- **Don't use property existence checks** like `'property' in object` or `hasOwnProperty`
- Make strong type assumptions based on context
- Use type guards sparingly and only when dealing with external data
- Example:
  ```typescript
  // ❌ Avoid
  if ('health' in entity && typeof entity.health === 'number') {
    entity.health -= damage;
  }
  
  // ✅ Prefer - assume the type based on context
  const player = entity as Player;
  player.health -= damage;
  ```

### 5. Strong Type Assumptions
- When you know the type from context, assert it confidently
- Use type assertions when converting between related types
- Don't over-validate types that are guaranteed by the system
- Example:
  ```typescript
  // ✅ Good - we know the world has these systems
  const combatSystem = world.getSystem('combat') as CombatSystem;
  const damage = combatSystem.calculateDamage(attacker, target);
  ```

### 6. Specific Type Patterns

#### For Event Handlers and Callbacks
```typescript
// Define specific event types
type InventoryAddEvent = {
  playerId: string;
  itemId: string;
  quantity: number;
};

// Use them directly
this.world.on('inventory:add', (event: InventoryAddEvent) => {
  // No need to check properties - assume they exist
  inventory.addItem(event.playerId, event.itemId, event.quantity);
});
```

#### For System Extensions
```typescript
// When extending systems, cast through unknown if needed
const extendedSystem = baseSystem as unknown as ExtendedSystemType;
```

#### For Collections and Maps
```typescript
// Use generic constraints
const entities = new Map<string, Entity>();
const items = new Map<ItemID, Item>();
```

### 7. Type Import Best Practices
- Always use `import type` for type-only imports
- Import from the most specific type file available
- Common type imports:
  ```typescript
  import type { World, System } from '../../types';
  import type { Entity, Item, Player } from '../types/core';
  import type { Position3D, Vector3 } from '../types/common';
  ```

### 8. Forbidden Patterns
- ❌ `as any` - NEVER use this
- ❌ `as unknown as any` - Double casting to any
- ❌ `{} as any` - Empty object to any
- ❌ `Function` type - Use specific function signatures
- ❌ `Object` type - Use specific object types
- ❌ Optional chaining for type narrowing - Make assumptions instead

### 9. Required Patterns
- ✅ Use non-null assertions when you know values exist: `value!`
- ✅ Use type predicates for reusable type guards
- ✅ Use const assertions for literal types: `as const`
- ✅ Define return types explicitly on public methods
- ✅ Use discriminated unions for variant types

Remember: The goal is to leverage TypeScript's type system to catch errors at compile time, not to add runtime checks that slow down the code. Trust the types!
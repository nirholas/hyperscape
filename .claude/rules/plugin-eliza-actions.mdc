---
description: Action implementation patterns for Hyperscape plugin
globs: packages/plugin-eliza/src/actions/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Action Patterns

> Patterns for implementing ElizaOS actions in the Hyperscape plugin.

## Reference Files

- Movement actions: @packages/plugin-eliza/src/actions/movement.ts
- Combat actions: @packages/plugin-eliza/src/actions/combat.ts
- Skills actions: @packages/plugin-eliza/src/actions/skills.ts
- Inventory actions: @packages/plugin-eliza/src/actions/inventory.ts
- Social actions: @packages/plugin-eliza/src/actions/social.ts
- Banking actions: @packages/plugin-eliza/src/actions/banking.ts

## Action Structure

Follow the ElizaOS Action interface exactly:

```typescript
import type { Action, IAgentRuntime, Memory, State, HandlerCallback } from '@elizaos/core';
import type { HyperscapeService } from '../services/HyperscapeService.js';

export const actionName: Action = {
  name: 'ACTION_NAME',
  similes: ['ALTERNATIVE_NAME', 'SIMILAR_NAME'],
  description: 'Clear description of what this action does',

  // Fast, deterministic validation
  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    const service = runtime.getService<HyperscapeService>('hyperscapeService');
    if (!service || !service.isConnected()) return false;
    
    const playerEntity = service.getPlayerEntity();
    if (!playerEntity || !playerEntity.alive) return false;
    
    // Check if message contains required input
    const text = message.content.text || '';
    return /* validation logic */;
  },

  // Handler executes the action
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: unknown,
    callback?: HandlerCallback
  ) => {
    try {
      const service = runtime.getService<HyperscapeService>('hyperscapeService');
      if (!service) {
        return { success: false, error: new Error('Service not available') };
      }

      // Parse inputs from message.content.text
      // Execute via service methods
      // Return ActionResult

      return {
        success: true,
        text: 'Action completed',
        values: { /* structured data */ },
        data: { action: 'ACTION_NAME' },
      };
    } catch (error) {
      logger.error('Action failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  },

  // Examples for LLM training - REQUIRED
  examples: [
    [
      { name: 'user', content: { text: 'Example user message' } },
      { name: 'assistant', content: { text: 'Example response', actions: ['ACTION_NAME'] } },
    ],
  ],
};
```

## Action Rules

- **ALWAYS** validate service availability and connection state
- **ALWAYS** parse inputs from `message.content.text`
- **ALWAYS** use service methods, never direct world access
- **ALWAYS** return proper `ActionResult` structure with `success`, `text`, `values`, `data`
- **ALWAYS** handle errors gracefully with callback notifications
- **ALWAYS** include `examples` array for LLM training
- **NEVER** store state in actions - use service or runtime
- **NEVER** perform side effects in `validate()` - keep it pure

## ActionResult Interface (MANDATORY)

**All actions MUST return proper ActionResult:**

```typescript
interface ActionResult {
  success: boolean;        // REQUIRED - Only required field
  text?: string;           // Optional human-readable description
  values?: Record<string, unknown>;  // Merged into state for chaining
  data?: Record<string, unknown>;   // Raw data for programmatic access
  error?: Error;          // Error information if failed
}
```

**Rules:**
- ✅ **ALWAYS** return ActionResult object (never void, boolean, or raw values)
- ✅ **ALWAYS** include `success` field (required)
- ✅ **ALWAYS** use `values` for data needed by subsequent actions
- ✅ **ALWAYS** use `data` for raw results and identifiers (for action chaining)
- ✅ **ALWAYS** return error in ActionResult, don't throw

## Handler Callback Pattern (MANDATORY)

**Use callbacks for user feedback:**

```typescript
await callback?.({
  text: `Starting to process your request...`,
  source: message.content.source,
  actions: ['ACTION_NAME']
});
```

**Rules:**
- ✅ **ALWAYS** use optional chaining: `callback?.()`
- ✅ **ALWAYS** send immediate feedback for long operations
- ✅ **ALWAYS** include `source` from `message.content.source`
- ✅ **ALWAYS** send error messages via callback before returning error
- ✅ **ALWAYS** provide progress updates for multi-step actions

## Action Chaining Pattern

**Access previous action results for chaining:**

```typescript
const context = options?.context as ActionContext;
const previousResult = context?.getPreviousResult?.('ACTION_NAME');

if (previousResult?.data?.key) {
  // Use data from previous action
}
```

**Rules:**
- ✅ **ALWAYS** check if previous result exists before using
- ✅ **ALWAYS** check `success` before using previous result data
- ✅ **ALWAYS** store identifiers in `data` for chaining
- ✅ **ALWAYS** use `values` for state that should be accessible
- ✅ **NEVER** assume previous action succeeded without checking

## Advanced Patterns

For advanced patterns (decision-making, multi-step, API integration, context-aware, composition), see:
- `.cursor/rules/plugin-eliza-action-patterns.mdc` - Advanced action patterns
- `.cursor/memory/elizaos-action-patterns.md` - Complete pattern reference

## File Organization

Group related actions in the same file:
- `movement.ts` - MOVE_TO, FOLLOW_ENTITY, STOP_MOVEMENT
- `combat.ts` - ATTACK_ENTITY, CHANGE_COMBAT_STYLE
- `skills.ts` - CHOP_TREE, CATCH_FISH, LIGHT_FIRE, COOK_FOOD
- `inventory.ts` - EQUIP_ITEM, USE_ITEM, DROP_ITEM
- `social.ts` - CHAT_MESSAGE
- `banking.ts` - BANK_DEPOSIT, BANK_WITHDRAW

## Common Patterns

### Service Access Pattern
```typescript
const service = runtime.getService<HyperscapeService>('hyperscapeService');
if (!service || !service.isConnected()) {
  return { success: false, error: new Error('Service not available') };
}
```

### Error Handling Pattern
```typescript
try {
  await service.executeAction(command);
  await callback?.({ text: 'Action completed', action: 'ACTION_NAME' });
  return { success: true, text: 'Success', values: {}, data: {} };
} catch (error) {
  await callback?.({ text: 'Action failed', error: true });
  return { success: false, error: error instanceof Error ? error : new Error(String(error)) };
}
```

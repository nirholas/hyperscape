---
description: Performance optimization patterns for Hyperscape plugin
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Performance Optimization

> Performance optimization patterns for state composition, providers, and services.

## Core Principles

1. **Cache when appropriate** - Use state cache for composed states
2. **Parallel execution** - Providers run concurrently
3. **Timeout handling** - Prevent slow operations from blocking
4. **Efficient data fetching** - Minimize external API calls
5. **Resource management** - Clean up resources properly
6. **Monitor performance** - Track duration and metrics

## State Composition Optimization

### Use Cache

```typescript
// Use cached state (default behavior)
const state = await runtime.composeState(message);

// Force fresh data only when needed
const freshState = await runtime.composeState(message, null, false, true);
```

**Rules:**
- ✅ **ALWAYS** use cache for performance (default)
- ✅ **ALWAYS** use `skipCache: true` only when fresh data is required
- ✅ **ALWAYS** consider cache invalidation needs
- ✅ **NEVER** skip cache unnecessarily

### Selective Provider Inclusion

```typescript
// Include only needed providers
const state = await runtime.composeState(message, ['CHARACTER', 'RECENT_MESSAGES'], true);

// Include dynamic providers only when needed
const state = await runtime.composeState(message, ['FACTS', 'ENTITIES']);
```

**Rules:**
- ✅ **ALWAYS** include only needed providers
- ✅ **ALWAYS** use `onlyInclude: true` for specific providers
- ✅ **ALWAYS** avoid including unnecessary dynamic providers
- ✅ **NEVER** include all providers when only few are needed

## Provider Performance

### Parallel Execution

Providers run concurrently by default. Ensure providers are designed for parallel execution:

```typescript
export const myProvider: Provider = {
  name: 'MY_PROVIDER',
  get: async (runtime, message, state) => {
    // This runs in parallel with other providers
    // Don't block on other providers
    const data = await fetchData();
    return { values: { data }, data: { data }, text: `Data: ${data}` };
  }
};
```

**Rules:**
- ✅ **ALWAYS** design providers for parallel execution
- ✅ **ALWAYS** avoid blocking operations
- ✅ **ALWAYS** use async/await for I/O
- ✅ **NEVER** wait for other providers in get method

### Timeout Handling

```typescript
export const timeoutProvider: Provider = {
  name: 'TIMEOUT_SAFE',
  get: async (runtime, message) => {
    const fetchData = async () => {
      const data = await externalAPI.fetch();
      return formatProviderResult(data);
    };

    return Promise.race([
      fetchData(),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), 5000)
      )
    ]).catch(error => {
      runtime.logger.warn(`[TIMEOUT_SAFE] Provider timeout:`, {
        error: error.message,
        timeout: 5000
      });
      return { values: {}, data: {}, text: '' };
    });
  }
};
```

**Rules:**
- ✅ **ALWAYS** implement timeouts for external calls
- ✅ **ALWAYS** use 5-second timeout for providers
- ✅ **ALWAYS** return empty result on timeout
- ✅ **ALWAYS** log timeout warnings
- ✅ **NEVER** let slow providers block state composition

### Efficient Data Fetching

```typescript
export const efficientProvider: Provider = {
  name: 'EFFICIENT_DATA',
  dynamic: true, // Only fetch when explicitly requested
  
  get: async (runtime, message, state) => {
    // Check cache first
    const cacheKey = `provider:${message.id}`;
    const cached = runtime.cache?.get(cacheKey);
    if (cached && !isExpired(cached)) {
      return cached;
    }

    // Fetch fresh data
    const data = await fetchData();

    // Cache result
    runtime.cache?.set(cacheKey, {
      values: { data },
      data: { data },
      text: `Data: ${data}`
    }, 60000); // Cache for 1 minute

    return {
      values: { data },
      data: { data },
      text: `Data: ${data}`
    };
  }
};
```

**Rules:**
- ✅ **ALWAYS** use cache when appropriate
- ✅ **ALWAYS** set `dynamic: true` for optional providers
- ✅ **ALWAYS** implement cache expiration
- ✅ **ALWAYS** limit cache size
- ✅ **NEVER** cache indefinitely

## Service Performance

### Connection Pooling

```typescript
export class EfficientService extends Service {
  private connectionPool: Connection[] = [];
  private readonly MAX_POOL_SIZE = 10;

  async getConnection(): Promise<Connection> {
    // Reuse existing connection
    const available = this.connectionPool.find(c => c.available);
    if (available) {
      return available;
    }

    // Create new connection if pool not full
    if (this.connectionPool.length < this.MAX_POOL_SIZE) {
      const connection = await this.createConnection();
      this.connectionPool.push(connection);
      return connection;
    }

    // Wait for available connection
    return this.waitForAvailableConnection();
  }
}
```

**Rules:**
- ✅ **ALWAYS** reuse connections when possible
- ✅ **ALWAYS** implement connection pooling
- ✅ **ALWAYS** limit pool size
- ✅ **ALWAYS** clean up connections properly

### Batch Operations

```typescript
export class BatchService extends Service {
  private batchQueue: Operation[] = [];
  private batchTimer: NodeJS.Timer | null = null;
  private readonly BATCH_SIZE = 10;
  private readonly BATCH_INTERVAL = 1000; // 1 second

  async queueOperation(operation: Operation) {
    this.batchQueue.push(operation);

    if (this.batchQueue.length >= this.BATCH_SIZE) {
      await this.processBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.processBatch();
        this.batchTimer = null;
      }, this.BATCH_INTERVAL);
    }
  }

  private async processBatch() {
    const batch = this.batchQueue.splice(0, this.BATCH_SIZE);
    await this.executeBatch(batch);
  }
}
```

**Rules:**
- ✅ **ALWAYS** batch operations when possible
- ✅ **ALWAYS** use appropriate batch size
- ✅ **ALWAYS** implement batch timeouts
- ✅ **ALWAYS** process batches efficiently

## Action Performance

### Efficient State Composition

```typescript
export const efficientAction: Action = {
  name: 'EFFICIENT_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    // Only compose state with needed providers
    const minimalState = await runtime.composeState(message, ['CHARACTER'], true);

    // Use cached state when possible
    const fullState = await runtime.composeState(message);

    // Perform action
    const result = await performAction(fullState);

    return { success: true, text: result.message };
  }
};
```

**Rules:**
- ✅ **ALWAYS** compose state with only needed providers
- ✅ **ALWAYS** use cache when possible
- ✅ **ALWAYS** avoid redundant state composition
- ✅ **NEVER** compose state multiple times unnecessarily

### Async Operation Optimization

```typescript
export const optimizedAction: Action = {
  name: 'OPTIMIZED_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    // Execute independent operations in parallel
    const [data1, data2, data3] = await Promise.all([
      fetchData1(),
      fetchData2(),
      fetchData3()
    ]);

    // Process results
    const result = processResults(data1, data2, data3);

    return { success: true, text: result.message };
  }
};
```

**Rules:**
- ✅ **ALWAYS** execute independent operations in parallel
- ✅ **ALWAYS** use Promise.all for parallel operations
- ✅ **ALWAYS** handle errors in parallel operations
- ✅ **NEVER** await operations sequentially when they can run in parallel

## Memory Management

### Cache Size Limits

```typescript
class BoundedCache extends Map {
  private maxSize: number;

  constructor(maxSize: number = 1000) {
    super();
    this.maxSize = maxSize;
  }

  set(key: string, value: any) {
    if (this.size >= this.maxSize) {
      const firstKey = this.keys().next().value;
      this.delete(firstKey);
    }
    return super.set(key, value);
  }
}
```

**Rules:**
- ✅ **ALWAYS** limit cache size
- ✅ **ALWAYS** implement cache eviction
- ✅ **ALWAYS** use LRU or FIFO eviction
- ✅ **NEVER** allow unbounded cache growth

### Resource Cleanup

```typescript
export class ResourceService extends Service {
  private resources: Set<Resource> = new Set();

  async cleanup() {
    // Clean up all resources
    for (const resource of this.resources) {
      try {
        await resource.cleanup();
      } catch (error) {
        this.runtime.logger.warn(`[ResourceService] Cleanup error:`, error);
      }
    }
    this.resources.clear();
  }
}
```

**Rules:**
- ✅ **ALWAYS** clean up resources properly
- ✅ **ALWAYS** track resources in Set or Map
- ✅ **ALWAYS** handle cleanup errors gracefully
- ✅ **NEVER** leave resources open

## Performance Monitoring

### Duration Tracking

```typescript
const startTime = Date.now();

try {
  await performOperation();
  
  const duration = Date.now() - startTime;
  
  runtime.logger.info(`[Component] Operation completed:`, {
    operation: 'OPERATION_NAME',
    duration,
    success: true
  });

  // Emit performance metric
  await runtime.emit(EventType.MODEL_USED, {
    runtime,
    duration,
    operation: 'OPERATION_NAME'
  });
} catch (error) {
  const duration = Date.now() - startTime;
  
  runtime.logger.error(`[Component] Operation failed:`, {
    operation: 'OPERATION_NAME',
    duration,
    error
  });
}
```

**Rules:**
- ✅ **ALWAYS** track duration for important operations
- ✅ **ALWAYS** log duration with operation name
- ✅ **ALWAYS** emit performance metrics
- ✅ **ALWAYS** include duration in error logs

## Best Practices Checklist

Before optimizing performance, verify:

- [ ] Using state cache appropriately
- [ ] Including only needed providers
- [ ] Implementing timeouts for external calls
- [ ] Using parallel execution where possible
- [ ] Implementing connection pooling
- [ ] Batching operations when appropriate
- [ ] Limiting cache size
- [ ] Cleaning up resources properly
- [ ] Tracking performance metrics
- [ ] Monitoring duration

## Forbidden Patterns

❌ **NEVER**:
- Skip cache unnecessarily
- Include all providers when only few are needed
- Let slow providers block state composition
- Create unbounded caches
- Skip resource cleanup
- Skip timeout handling
- Execute operations sequentially when they can run in parallel

## Required Patterns

✅ **ALWAYS**:
- Use state cache for performance
- Include only needed providers
- Implement timeouts for external calls
- Design providers for parallel execution
- Use connection pooling
- Batch operations when possible
- Limit cache size
- Clean up resources properly
- Track performance metrics
- Monitor duration

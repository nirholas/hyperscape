---
description: Logging patterns and standards for Hyperscape plugin
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Logging Patterns

> Consistent logging patterns across actions, providers, services, and handlers.

## Core Principles

1. **Use structured logging** - Log data as objects, not strings
2. **Include context** - Always include relevant context (messageId, entityId, etc.)
3. **Appropriate log levels** - Use error, warn, info, debug appropriately
4. **Component identification** - Always include component name in logs
5. **No sensitive data** - Never log API keys, passwords, or tokens
6. **Reasonable data size** - Limit log data to 500 characters

## Logger Usage

### Import Pattern

```typescript
import { logger } from '@elizaos/core';

// Or use runtime logger
runtime.logger.error(...);
runtime.logger.warn(...);
runtime.logger.info(...);
runtime.logger.debug(...);
```

**Rules:**
- ✅ **ALWAYS** use `logger` from `@elizaos/core` or `runtime.logger`
- ✅ **ALWAYS** use structured logging (objects, not strings)
- ✅ **NEVER** use `console.log` in production code
- ✅ **NEVER** use `console.error` directly

## Log Levels

### Error - Critical Failures

```typescript
runtime.logger.error(`[ComponentName] Error message:`, {
  error,
  context: {
    messageId: message.id,
    entityId: message.entityId,
    roomId: message.roomId,
    action: 'ACTION_NAME'
  }
});
```

**Use for:**
- Unhandled exceptions
- Service failures
- Critical operation failures
- Data corruption

**Rules:**
- ✅ **ALWAYS** include error object
- ✅ **ALWAYS** include relevant context
- ✅ **ALWAYS** include component name
- ✅ **NEVER** log sensitive information

### Warn - Recoverable Issues

```typescript
runtime.logger.warn(`[ComponentName] Warning message:`, {
  reason: 'Service not configured',
  fallback: 'Using default behavior',
  component: 'ComponentName'
});
```

**Use for:**
- Missing optional configuration
- Degraded functionality
- Retry attempts
- Timeout warnings

**Rules:**
- ✅ **ALWAYS** include reason for warning
- ✅ **ALWAYS** include fallback behavior
- ✅ **ALWAYS** include component name

### Info - Important Events

```typescript
runtime.logger.info(`[ComponentName] Info message:`, {
  action: 'ACTION_NAME',
  result: 'success',
  duration: Date.now() - startTime,
  messageId: message.id
});
```

**Use for:**
- Successful operations
- State changes
- Important events
- Performance metrics

**Rules:**
- ✅ **ALWAYS** include action/operation name
- ✅ **ALWAYS** include result/outcome
- ✅ **ALWAYS** include relevant metrics

### Debug - Development Details

```typescript
runtime.logger.debug(`[ComponentName] Debug message:`, {
  step: 'processing',
  data: sanitizedData,
  state: state?.values
});
```

**Use for:**
- Development debugging
- Detailed operation steps
- State inspection
- Flow tracing

**Rules:**
- ✅ **ALWAYS** use debug level for development
- ✅ **ALWAYS** sanitize data before logging
- ✅ **NEVER** log sensitive information

## Component-Specific Patterns

### Action Logging

```typescript
export const myAction: Action = {
  name: 'MY_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    const startTime = Date.now();
    runtime.logger.info(`[MY_ACTION] Starting execution:`, {
      messageId: message.id,
      entityId: message.entityId,
      roomId: message.roomId
    });

    try {
      // Action logic
      const result = await performAction();

      runtime.logger.info(`[MY_ACTION] Completed successfully:`, {
        messageId: message.id,
        duration: Date.now() - startTime,
        result: 'success'
      });

      return { success: true, text: result.message };
    } catch (error) {
      runtime.logger.error(`[MY_ACTION] Execution failed:`, {
        error,
        messageId: message.id,
        entityId: message.entityId,
        roomId: message.roomId,
        duration: Date.now() - startTime
      });

      return { success: false, error };
    }
  }
};
```

**Rules:**
- ✅ **ALWAYS** log action start with context
- ✅ **ALWAYS** log action completion (success or failure)
- ✅ **ALWAYS** include duration for performance tracking
- ✅ **ALWAYS** include messageId, entityId, roomId

### Provider Logging

```typescript
export const myProvider: Provider = {
  name: 'MY_PROVIDER',
  get: async (runtime, message, state) => {
    try {
      const data = await fetchData();
      
      runtime.logger.debug(`[MY_PROVIDER] Data fetched:`, {
        messageId: message.id,
        dataSize: JSON.stringify(data).length
      });

      return {
        values: { myData: data.summary },
        data: { myData: data },
        text: `Provider data: ${data.summary}`
      };
    } catch (error) {
      runtime.logger.warn(`[MY_PROVIDER] Failed to fetch data:`, {
        error,
        messageId: message.id,
        fallback: 'Returning empty result'
      });

      return { values: {}, data: {}, text: '' };
    }
  }
};
```

**Rules:**
- ✅ **ALWAYS** use debug level for successful fetches
- ✅ **ALWAYS** use warn level for failures
- ✅ **ALWAYS** include messageId
- ✅ **NEVER** log full data (only size or summary)

### Service Logging

```typescript
export class MyService extends Service {
  static async start(runtime: IAgentRuntime): Promise<Service> {
    runtime.logger.info(`[MyService] Starting initialization`);
    
    try {
      const service = new MyService(runtime);
      await service.initialize();
      
      runtime.logger.info(`[MyService] Initialized successfully`);
      return service;
    } catch (error) {
      runtime.logger.error(`[MyService] Initialization failed:`, {
        error,
        fallback: 'Service created with reduced functionality'
      });
      
      const service = new MyService(runtime);
      service.initialized = false;
      return service;
    }
  }

  async stop() {
    runtime.logger.info(`[MyService] Stopping service`);
    
    try {
      await this.cleanup();
      runtime.logger.info(`[MyService] Stopped gracefully`);
    } catch (error) {
      runtime.logger.error(`[MyService] Error during stop:`, {
        error,
        action: 'Force cleanup'
      });
      this.forceCleanup();
    }
  }
}
```

**Rules:**
- ✅ **ALWAYS** log service lifecycle events (start, stop)
- ✅ **ALWAYS** log initialization success/failure
- ✅ **ALWAYS** log cleanup operations
- ✅ **ALWAYS** include error context

## Log Context Patterns

### Standard Context

```typescript
const logContext = {
  component: 'ComponentName',
  messageId: message.id,
  entityId: message.entityId,
  roomId: message.roomId,
  action: 'ACTION_NAME',
  timestamp: Date.now()
};
```

### Service Context

```typescript
const logContext = {
  component: 'ServiceName',
  serviceType: 'service-type',
  connectionState: this.isConnected(),
  timestamp: Date.now()
};
```

### Error Context

```typescript
const errorContext = {
  error: error.message,
  stack: error.stack?.slice(0, 500), // Limit stack trace
  component: 'ComponentName',
  operation: 'OPERATION_NAME',
  context: { /* relevant context */ }
};
```

**Rules:**
- ✅ **ALWAYS** include component name
- ✅ **ALWAYS** include relevant IDs (messageId, entityId, roomId)
- ✅ **ALWAYS** include operation/action name
- ✅ **ALWAYS** limit data size (500 chars for strings)
- ✅ **NEVER** include sensitive information

## Data Sanitization

### Sanitize Before Logging

```typescript
function sanitizeForLogging(data: any): any {
  const sanitized = { ...data };
  
  // Remove sensitive fields
  delete sanitized.apiKey;
  delete sanitized.password;
  delete sanitized.token;
  delete sanitized.secret;
  
  // Limit string length
  for (const key in sanitized) {
    if (typeof sanitized[key] === 'string' && sanitized[key].length > 500) {
      sanitized[key] = sanitized[key].slice(0, 500) + '...';
    }
  }
  
  return sanitized;
}

runtime.logger.info(`[Component] Data:`, sanitizeForLogging(data));
```

**Rules:**
- ✅ **ALWAYS** sanitize data before logging
- ✅ **ALWAYS** remove sensitive fields
- ✅ **ALWAYS** limit string length
- ✅ **NEVER** log full API keys or tokens
- ✅ **NEVER** log passwords or secrets

## Performance Logging

### Duration Tracking

```typescript
const startTime = Date.now();

try {
  await performOperation();
  
  runtime.logger.info(`[Component] Operation completed:`, {
    operation: 'OPERATION_NAME',
    duration: Date.now() - startTime,
    success: true
  });
} catch (error) {
  runtime.logger.error(`[Component] Operation failed:`, {
    operation: 'OPERATION_NAME',
    duration: Date.now() - startTime,
    error
  });
}
```

**Rules:**
- ✅ **ALWAYS** track duration for important operations
- ✅ **ALWAYS** log duration with operation name
- ✅ **ALWAYS** include duration in error logs

## Best Practices Checklist

Before adding logging, verify:

- [ ] Using logger from @elizaos/core or runtime.logger
- [ ] Using structured logging (objects, not strings)
- [ ] Including component name in logs
- [ ] Including relevant context (messageId, entityId, etc.)
- [ ] Using appropriate log level (error, warn, info, debug)
- [ ] Sanitizing sensitive data
- [ ] Limiting data size (500 chars)
- [ ] Including duration for performance tracking
- [ ] Not logging sensitive information
- [ ] Not using console.log in production

## Forbidden Patterns

❌ **NEVER**:
- Use console.log in production code
- Log sensitive information (API keys, passwords, tokens)
- Log excessive data (limit to 500 chars)
- Skip component name in logs
- Skip context in logs
- Use wrong log level
- Log full error stacks without limits

## Required Patterns

✅ **ALWAYS**:
- Use logger from @elizaos/core or runtime.logger
- Use structured logging (objects)
- Include component name
- Include relevant context
- Use appropriate log level
- Sanitize sensitive data
- Limit data size
- Track duration for important operations
- Include error context in error logs

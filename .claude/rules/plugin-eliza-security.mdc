---
description: Security patterns for Hyperscape plugin - API keys, input validation, WebSocket security
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Security Patterns

> Security best practices for API keys, input validation, and WebSocket communication.

## Core Principles

1. **Never expose secrets** - API keys and tokens in environment variables only
2. **Validate all inputs** - Use Zod or type guards for validation
3. **Sanitize outputs** - Remove sensitive data from logs and responses
4. **Secure connections** - Use WSS (WebSocket Secure) in production
5. **Principle of least privilege** - Only request necessary permissions
6. **Error message safety** - Don't leak sensitive information in errors

## API Key Management

### Environment Variables

```typescript
// ✅ CORRECT: Get from runtime settings
const apiKey = runtime.getSetting('OPENAI_API_KEY');
if (!apiKey) {
  runtime.logger.warn('[Service] API key not configured');
  return;
}

// ❌ WRONG: Hardcoded keys
const apiKey = 'sk-1234567890abcdef';
```

**Rules:**
- ✅ **ALWAYS** use `runtime.getSetting()` for API keys
- ✅ **ALWAYS** check for missing keys gracefully
- ✅ **ALWAYS** store keys in environment variables
- ✅ **NEVER** hardcode API keys in source code
- ✅ **NEVER** commit API keys to version control
- ✅ **NEVER** log API keys

### Key Validation

```typescript
export class SecureService extends Service {
  private validateApiKey(key: string | undefined): string {
    if (!key) {
      throw new Error('API key not configured');
    }

    if (key.length < 10) {
      throw new Error('Invalid API key format');
    }

    // Validate key format (example)
    if (!key.startsWith('sk-') && !key.startsWith('gsk_')) {
      throw new Error('Invalid API key format');
    }

    return key;
  }

  static async start(runtime: IAgentRuntime): Promise<Service> {
    const apiKey = runtime.getSetting('API_KEY');
    const validatedKey = this.validateApiKey(apiKey);
    
    const service = new SecureService(runtime);
    await service.initialize(validatedKey);
    return service;
  }
}
```

**Rules:**
- ✅ **ALWAYS** validate API key format
- ✅ **ALWAYS** check key length
- ✅ **ALWAYS** validate key prefix when applicable
- ✅ **NEVER** accept empty or null keys
- ✅ **NEVER** skip key validation

## Input Validation

### Zod Schema Validation

```typescript
import { z } from 'zod';

const ActionInputSchema = z.object({
  targetId: z.string().uuid(),
  action: z.enum(['attack', 'gather', 'interact']),
  parameters: z.record(z.unknown()).optional()
});

export const validatedAction: Action = {
  name: 'VALIDATED_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    try {
      // Validate input
      const input = ActionInputSchema.parse(message.content);
      
      // Use validated input
      const result = await performAction(input);
      
      return { success: true, text: result.message };
    } catch (error) {
      if (error instanceof z.ZodError) {
        await callback?.({
          text: 'Invalid input: please check your request',
          error: true
        });
        return {
          success: false,
          error: new Error('Invalid input')
        };
      }
      throw error;
    }
  }
};
```

**Rules:**
- ✅ **ALWAYS** validate inputs with Zod schemas
- ✅ **ALWAYS** validate at action/provider boundaries
- ✅ **ALWAYS** return clear error messages for invalid input
- ✅ **NEVER** skip input validation
- ✅ **NEVER** trust user input

### Type Guards

```typescript
function isValidEntityId(id: unknown): id is string {
  return typeof id === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id);
}

function isValidPosition(pos: unknown): pos is { x: number; y: number; z: number } {
  return (
    typeof pos === 'object' &&
    pos !== null &&
    'x' in pos &&
    'y' in pos &&
    'z' in pos &&
    typeof (pos as any).x === 'number' &&
    typeof (pos as any).y === 'number' &&
    typeof (pos as any).z === 'number'
  );
}
```

**Rules:**
- ✅ **ALWAYS** use type guards for runtime validation
- ✅ **ALWAYS** validate UUIDs, positions, and other structured data
- ✅ **ALWAYS** return boolean from type guards
- ✅ **NEVER** skip type guards for external data

## Output Sanitization

### Log Sanitization

```typescript
function sanitizeForLogging(data: any): any {
  const sanitized = { ...data };
  
  // Remove sensitive fields
  const sensitiveFields = ['apiKey', 'password', 'token', 'secret', 'privateKey'];
  for (const field of sensitiveFields) {
    delete sanitized[field];
  }
  
  // Mask partial keys (show only last 4 chars)
  if (sanitized.key && typeof sanitized.key === 'string') {
    sanitized.key = `***${sanitized.key.slice(-4)}`;
  }
  
  // Limit string length
  for (const key in sanitized) {
    if (typeof sanitized[key] === 'string' && sanitized[key].length > 500) {
      sanitized[key] = sanitized[key].slice(0, 500) + '...';
    }
  }
  
  return sanitized;
}

runtime.logger.info(`[Component] Data:`, sanitizeForLogging(data));
```

**Rules:**
- ✅ **ALWAYS** sanitize data before logging
- ✅ **ALWAYS** remove sensitive fields
- ✅ **ALWAYS** mask partial keys when needed
- ✅ **ALWAYS** limit string length
- ✅ **NEVER** log full API keys or tokens
- ✅ **NEVER** log passwords or secrets

### Response Sanitization

```typescript
export const secureAction: Action = {
  name: 'SECURE_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    const result = await performAction();
    
    // Sanitize response before sending
    const sanitizedResult = {
      ...result,
      // Remove sensitive fields
      apiKey: undefined,
      token: undefined,
      // Keep only safe fields
      message: result.message,
      data: result.safeData
    };
    
    await callback?.(sanitizedResult);
    
    return {
      success: true,
      text: sanitizedResult.message,
      data: sanitizedResult.data
    };
  }
};
```

**Rules:**
- ✅ **ALWAYS** sanitize responses before sending
- ✅ **ALWAYS** remove sensitive fields from responses
- ✅ **ALWAYS** keep only safe fields
- ✅ **NEVER** expose sensitive data in responses

## WebSocket Security

### Connection Security

```typescript
export class SecureWebSocketService extends Service {
  private getWebSocketUrl(): string {
    const url = this.runtime.getSetting('HYPERSCAPE_WORLD_URL') || 'ws://localhost:5555';
    
    // Force WSS in production
    if (process.env.NODE_ENV === 'production' && url.startsWith('ws://')) {
      return url.replace('ws://', 'wss://');
    }
    
    return url;
  }

  async connect() {
    const url = this.getWebSocketUrl();
    
    // Validate URL
    if (!this.isValidWebSocketUrl(url)) {
      throw new Error('Invalid WebSocket URL');
    }
    
    this.ws = new WebSocket(url);
    // ... connection logic
  }

  private isValidWebSocketUrl(url: string): boolean {
    try {
      const parsed = new URL(url);
      return parsed.protocol === 'ws:' || parsed.protocol === 'wss:';
    } catch {
      return false;
    }
  }
}
```

**Rules:**
- ✅ **ALWAYS** use WSS (WebSocket Secure) in production
- ✅ **ALWAYS** validate WebSocket URLs
- ✅ **ALWAYS** check URL protocol
- ✅ **NEVER** use WS (unencrypted) in production
- ✅ **NEVER** accept arbitrary URLs

### Message Validation

```typescript
const WebSocketMessageSchema = z.object({
  type: z.enum(['join', 'message', 'action', 'position']),
  payload: z.record(z.unknown()),
  timestamp: z.number().optional()
});

private async handleMessage(rawMessage: string) {
  try {
    const parsed = JSON.parse(rawMessage);
    const message = WebSocketMessageSchema.parse(parsed);
    
    // Process validated message
    await this.processMessage(message);
  } catch (error) {
    this.runtime.logger.warn('[WebSocket] Invalid message:', {
      error: error instanceof Error ? error.message : 'Unknown error',
      message: rawMessage.slice(0, 100) // Log only first 100 chars
    });
    
    // Reject invalid message
    this.ws?.send(JSON.stringify({
      type: 'error',
      error: 'Invalid message format'
    }));
  }
}
```

**Rules:**
- ✅ **ALWAYS** validate WebSocket messages
- ✅ **ALWAYS** use Zod schemas for message validation
- ✅ **ALWAYS** reject invalid messages
- ✅ **ALWAYS** log validation errors
- ✅ **NEVER** process unvalidated messages

## Error Message Safety

### Safe Error Messages

```typescript
// ✅ CORRECT: Generic error message
catch (error) {
  runtime.logger.error('[Component] Error:', {
    error: error.message,
    // Don't expose internal details
  });
  
  await callback?.({
    text: 'An error occurred. Please try again.',
    error: true
  });
  
  return {
    success: false,
    error: new Error('Operation failed')
  };
}

// ❌ WRONG: Exposing internal details
catch (error) {
  await callback?.({
    text: `Database error: ${error.message} - Connection failed to ${dbHost}:${dbPort}`,
    error: true
  });
}
```

**Rules:**
- ✅ **ALWAYS** use generic error messages for users
- ✅ **ALWAYS** log detailed errors internally
- ✅ **ALWAYS** avoid exposing internal details
- ✅ **NEVER** expose database connection details
- ✅ **NEVER** expose file paths or system information
- ✅ **NEVER** expose API keys or tokens in errors

## Best Practices Checklist

Before implementing security, verify:

- [ ] API keys stored in environment variables
- [ ] API keys validated before use
- [ ] Inputs validated with Zod schemas
- [ ] Outputs sanitized before logging/sending
- [ ] WebSocket connections use WSS in production
- [ ] WebSocket messages validated
- [ ] Error messages don't expose sensitive information
- [ ] Sensitive data removed from logs
- [ ] Type guards used for runtime validation
- [ ] Principle of least privilege followed

## Forbidden Patterns

❌ **NEVER**:
- Hardcode API keys in source code
- Commit API keys to version control
- Log API keys or tokens
- Skip input validation
- Expose sensitive data in error messages
- Use WS (unencrypted) in production
- Process unvalidated WebSocket messages
- Trust user input without validation

## Required Patterns

✅ **ALWAYS**:
- Use environment variables for API keys
- Validate API keys before use
- Validate inputs with Zod schemas
- Sanitize outputs before logging/sending
- Use WSS in production
- Validate WebSocket messages
- Use generic error messages for users
- Remove sensitive data from logs
- Use type guards for runtime validation
- Follow principle of least privilege

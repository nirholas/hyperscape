---
description: ElizaOS action patterns - chaining, callbacks, composition, and advanced patterns
globs: packages/plugin-eliza/src/actions/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Action Patterns

> Advanced action patterns: chaining, callbacks, composition, and real-world implementations.

## Reference Documentation

- **Action Patterns**: https://docs.elizaos.ai/plugins/patterns
- **Action Interface**: https://docs.elizaos.ai/plugins/reference#action-interface
- **Plugin Components**: https://docs.elizaos.ai/plugins/components
- **Memory**: `.cursor/memory/elizaos-action-patterns.md`

## ActionResult Interface

**MANDATORY**: All actions MUST return proper ActionResult structure:

```typescript
interface ActionResult {
  success: boolean;        // REQUIRED - Only required field
  text?: string;           // Optional human-readable description
  values?: Record<string, unknown>;  // Merged into state for chaining
  data?: Record<string, unknown>;   // Raw data for programmatic access
  error?: Error;          // Error information if failed
}
```

**Rules:**
- ‚úÖ **ALWAYS** return ActionResult object (never void, boolean, or raw values)
- ‚úÖ **ALWAYS** include `success` field (required)
- ‚úÖ **ALWAYS** use `values` for data needed by subsequent actions
- ‚úÖ **ALWAYS** use `data` for raw results and identifiers
- ‚úÖ **ALWAYS** return error in ActionResult, don't throw

## Handler Callback Pattern

**MANDATORY**: Use callbacks for user feedback:

```typescript
await callback?.({
  text: `Starting to process your request...`,
  source: message.content.source,
  actions: ['ACTION_NAME']
});
```

**Rules:**
- ‚úÖ **ALWAYS** use optional chaining: `callback?.()`
- ‚úÖ **ALWAYS** send immediate feedback for long operations
- ‚úÖ **ALWAYS** include `source` from `message.content.source`
- ‚úÖ **ALWAYS** send error messages via callback before returning error
- ‚úÖ **ALWAYS** provide progress updates for multi-step actions

## Action Chaining Pattern

**MANDATORY**: Access previous action results for chaining:

```typescript
const context = options?.context as ActionContext;
const previousResult = context?.getPreviousResult?.('ACTION_NAME');

if (previousResult?.data?.key) {
  // Use data from previous action
}
```

**Rules:**
- ‚úÖ **ALWAYS** check if previous result exists before using
- ‚úÖ **ALWAYS** check `success` before using previous result data
- ‚úÖ **ALWAYS** store identifiers in `data` for chaining
- ‚úÖ **ALWAYS** use `values` for state that should be accessible
- ‚úÖ **NEVER** assume previous action succeeded without checking

## Action Patterns

### Decision-Making Actions

**Pattern:** Use LLM for intelligent decisions

```typescript
const prompt = composePromptFromState({ state, template: decisionTemplate });
const decision = await runtime.useModel(ModelType.TEXT_SMALL, { prompt, runtime });

if (decision.toLowerCase().includes('yes')) {
  return { success: true, text: 'Decision made', values: { decision: true } };
}
return { success: false, text: 'Decision not made' };
```

**Rules:**
- ‚úÖ Use `ModelType.TEXT_SMALL` for decisions (faster, cheaper)
- ‚úÖ Store decision in `values` for state access
- ‚úÖ Return ActionResult based on decision

### Multi-Step Actions

**Pattern:** Multiple steps with intermediate feedback

```typescript
// Step 1
await callback?.({ text: 'üìù Step 1: Starting...', actions: ['ACTION_NAME'] });
const step1Result = await performStep1();

// Step 2
await callback?.({ text: '‚õΩ Step 2: Processing...', actions: ['ACTION_NAME'] });
const step2Result = await performStep2(step1Result);

// Final result
return {
  success: true,
  text: 'All steps completed',
  values: { step1: step1Result, step2: step2Result },
  data: { results: [step1Result, step2Result] }
};
```

**Rules:**
- ‚úÖ **ALWAYS** provide callback feedback for each step
- ‚úÖ **ALWAYS** accumulate results in `data` object
- ‚úÖ **ALWAYS** handle errors at each step
- ‚úÖ **ALWAYS** return aggregated results

### API Integration Actions

**Pattern:** External API calls with retries

```typescript
const maxRetries = 3;
let lastError: Error | null = null;

for (let attempt = 1; attempt <= maxRetries; attempt++) {
  try {
    await callback?.({ text: `Attempt ${attempt}/${maxRetries}...` });
    const result = await callExternalAPI({ /* params */ });
    return { success: true, text: 'API call successful', data: result };
  } catch (error) {
    lastError = error as Error;
    if (attempt < maxRetries) {
      await callback?.({ text: `Attempt ${attempt} failed, retrying...` });
      await new Promise(r => setTimeout(r, 1000 * attempt)); // Exponential backoff
    }
  }
}

return {
  success: false,
  text: `API call failed after ${maxRetries} attempts`,
  error: lastError
};
```

**Rules:**
- ‚úÖ **ALWAYS** implement retry logic with exponential backoff
- ‚úÖ **ALWAYS** use callbacks for retry attempts
- ‚úÖ **ALWAYS** return error details on failure
- ‚úÖ **ALWAYS** store API response in `data`

### Context-Aware Actions

**Pattern:** Adapt based on conversation context

```typescript
const sentiment = await analyzeSentiment(state.recentMessages);
const responseStrategy = sentiment.score < -0.5 ? 'empathetic' : 'enthusiastic';
const response = await generateResponse(state, responseStrategy, runtime);

return {
  success: true,
  text: response.text,
  values: { sentiment: sentiment.score, strategy: responseStrategy }
};
```

**Rules:**
- ‚úÖ Analyze context before acting
- ‚úÖ Store context analysis in `values`
- ‚úÖ Adapt behavior based on analysis

## Action Composition

### Compose Multiple Actions

**Pattern:** Higher-level actions executing sub-actions

```typescript
const sendResult = await sendMessageAction.handler(
  runtime, message, state, options, callback
);

if (!sendResult.success) {
  return sendResult; // Propagate failure
}

// Continue with next action
const trackResult = await trackMessage(sendResult.data.messageId);

return {
  success: true,
  text: 'Message sent and tracked',
  values: { ...sendResult.values, trackingId: trackResult.id },
  data: { sendResult, trackResult }
};
```

**Rules:**
- ‚úÖ **ALWAYS** propagate failures from sub-actions
- ‚úÖ **ALWAYS** merge results from sub-actions
- ‚úÖ **ALWAYS** create composite data structure

### Workflow Orchestration

**Pattern:** Execute multiple actions in sequence

```typescript
const workflow = [
  { action: 'VALIDATE_INPUT', required: true },
  { action: 'FETCH_DATA', required: true },
  { action: 'PROCESS_DATA', required: false },
  { action: 'STORE_RESULTS', required: true }
];

const results: ActionResult[] = [];

for (const step of workflow) {
  const action = runtime.getAction(step.action);
  if (!action && step.required) {
    return { success: false, text: `Required action ${step.action} not found` };
  }
  
  const result = await action.handler(
    runtime, message, state,
    { context: { previousResults: results } },
    callback
  );
  
  results.push(result);
  
  if (!result.success && step.required) {
    return { success: false, text: `Workflow failed at ${step.action}`, data: { results } };
  }
  
  // Merge values into state for next action
  state = { ...state, values: { ...state.values, ...result.values } };
}

return { success: true, text: 'Workflow completed', data: { workflowResults: results } };
```

**Rules:**
- ‚úÖ **ALWAYS** define workflow steps with required flags
- ‚úÖ **ALWAYS** execute sequentially
- ‚úÖ **ALWAYS** merge state between steps
- ‚úÖ **ALWAYS** handle required vs optional steps
- ‚úÖ **ALWAYS** return aggregated results

## Provider Patterns

### Conditional Providers

**Pattern:** Provide data only under certain conditions

```typescript
export const conditionalProvider: Provider = {
  name: 'PREMIUM_DATA',
  private: true,
  
  get: async (runtime, message, state) => {
    const user = await runtime.getUser(message.entityId);
    
    if (!user.isPremium) {
      return { text: '', values: {}, data: { available: false } };
    }
    
    const premiumData = await fetchPremiumData(user);
    return {
      text: formatPremiumData(premiumData),
      values: premiumData,
      data: { available: true, ...premiumData }
    };
  }
};
```

**Rules:**
- ‚úÖ **ALWAYS** return empty data gracefully if conditions not met
- ‚úÖ **ALWAYS** use `private: true` if provider should be hidden
- ‚úÖ **ALWAYS** handle unavailable data gracefully

### Aggregating Providers

**Pattern:** Combine data from multiple sources

```typescript
export const aggregateProvider: Provider = {
  name: 'MARKET_OVERVIEW',
  position: 50, // Run after individual providers
  
  get: async (runtime, message, state) => {
    const [stocks, crypto, forex] = await Promise.all([
      fetchStockData(),
      fetchCryptoData(),
      fetchForexData()
    ]);
    
    const overview = aggregateData(stocks, crypto, forex);
    
    return {
      text: formatOverview(overview),
      values: overview,
      data: { stocks, crypto, forex }
    };
  }
};
```

**Rules:**
- ‚úÖ **ALWAYS** use `position` to run after individual providers
- ‚úÖ **ALWAYS** use `Promise.all` for parallel fetching
- ‚úÖ **ALWAYS** aggregate and format data clearly
- ‚úÖ **ALWAYS** return comprehensive overview

## Best Practices Checklist

Before implementing any action, verify:

- [ ] Returns proper ActionResult structure
- [ ] Uses callbacks for user feedback
- [ ] Stores identifiers in `data` for chaining
- [ ] Handles missing dependencies gracefully
- [ ] Implements proper error handling
- [ ] Includes examples array for LLM training
- [ ] Validates service availability
- [ ] Uses proper TypeScript types
- [ ] Follows action chaining patterns if needed
- [ ] Provides progress updates for long operations

## Forbidden Patterns

‚ùå **NEVER**:
- Return void, boolean, or raw values (always return ActionResult)
- Throw errors (return error in ActionResult)
- Skip callbacks for long operations
- Assume previous actions succeeded without checking
- Store chaining data in wrong location (use `data` for IDs, `values` for state)
- Skip error handling in async operations
- Use wrong model type for decisions (use TEXT_SMALL, not TEXT_LARGE)

## Required Patterns

‚úÖ **ALWAYS**:
- Return ActionResult with `success` field
- Use callbacks for immediate feedback
- Check previous results before using in chaining
- Store identifiers in `data` for chaining
- Handle errors gracefully with callbacks
- Implement retry logic for API calls
- Provide progress updates for multi-step actions
- Use proper model types for different tasks

## Common Workflow Patterns

1. **Create and Configure**: Create resource ‚Üí Configure it
2. **Search and Update**: Find resources ‚Üí Modify them
3. **Validate and Execute**: Check conditions ‚Üí Perform actions
4. **Aggregate and Report**: Collect data ‚Üí Summarize

## Examples

See `.cursor/memory/elizaos-action-patterns.md` for complete examples of:
- Decision-making actions
- Multi-step workflows
- API integration patterns
- Context-aware actions
- Action composition
- Workflow orchestration

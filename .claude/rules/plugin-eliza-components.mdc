---
description: ElizaOS plugin components - Actions, Providers, Evaluators, Services interfaces and patterns
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Components

> Component interfaces, execution flow, and interaction patterns.

## Reference Documentation

- **Plugin Components**: https://docs.elizaos.ai/plugins/components
- **Plugin Architecture**: https://docs.elizaos.ai/plugins/architecture
- **Memory**: `.cursor/memory/elizaos-architecture-components.md`

## Component Overview

| Component      | Purpose                            | When Executed                     |
| -------------- | ---------------------------------- | --------------------------------- |
| **Actions**    | Tasks agents can perform           | When agent decides to take action |
| **Providers**  | Supply contextual data             | Before actions/decisions          |
| **Evaluators** | Process and extract from responses | After agent generates response    |
| **Services**   | Manage stateful connections        | Throughout agent lifecycle        |

## Actions

**Purpose:** What agents can DO

**Interface:**
```typescript
interface Action {
  name: string;                    // REQUIRED - Unique identifier
  description: string;             // REQUIRED - What action does
  similes?: string[];              // Alternative names for matching
  examples?: ActionExample[][];    // Training examples
  validate: (runtime, message, state) => Promise<boolean>;
  handler: (runtime, message, state, options, callback) => Promise<ActionResult>;
}
```

**Core Actions (Bootstrap Plugin):**
- Communication: REPLY, SEND_MESSAGE, NONE, IGNORE
- Room Management: FOLLOW_ROOM, UNFOLLOW_ROOM, MUTE_ROOM, UNMUTE_ROOM
- Data & Config: UPDATE_CONTACT, UPDATE_ROLE, UPDATE_SETTINGS
- Media & Utilities: GENERATE_IMAGE, CHOICE

**Rules:**
- ✅ **ALWAYS** return ActionResult with `success` field
- ✅ **ALWAYS** implement `validate` (fast and deterministic)
- ✅ **ALWAYS** implement `handler` (execution logic)
- ✅ **ALWAYS** include `examples` array for LLM training
- ✅ **ALWAYS** use `similes` for alternative names
- ✅ **NEVER** perform side effects in `validate()`
- ✅ **NEVER** throw errors (return error in ActionResult)

**See Also:**
- `.cursor/rules/plugin-eliza-actions.mdc` - Action implementation patterns
- `.cursor/rules/plugin-eliza-action-patterns.mdc` - Advanced action patterns

## Providers

**Purpose:** Supply contextual data to agent

**Interface:**
```typescript
interface Provider {
  name: string;                    // REQUIRED - Unique identifier
  description?: string;            // Optional explanation
  dynamic?: boolean;               // true = re-fetched each time
  position?: number;               // Execution order (-100 to 100)
  private?: boolean;               // Hide from provider list
  get: (runtime, message, state?) => Promise<ProviderResult>;
}

interface ProviderResult {
  text: string;                    // Formatted for LLM
  values?: Record<string, unknown>; // Structured data for templates
  data?: Record<string, unknown>;   // Raw data for processing
}
```

**Core Providers (Bootstrap Plugin):**
- characterProvider - Agent personality
- timeProvider - Current date/time
- knowledgeProvider - Knowledge base
- recentMessagesProvider - Chat history
- actionsProvider - Available actions
- factsProvider - Stored facts
- settingsProvider - Configuration

**Rules:**
- ✅ **ALWAYS** set `dynamic: true` for real-time data
- ✅ **ALWAYS** set `position` number for ordering
- ✅ **ALWAYS** return ProviderResult with text, values, data
- ✅ **ALWAYS** format text clearly for LLM
- ✅ **ALWAYS** handle missing data gracefully
- ✅ **NEVER** cache dynamic provider results
- ✅ **NEVER** perform side effects (read-only)

**Provider Ordering:**
- Lower numbers = higher priority (run first)
- Position: -100 (loads first) to 100 (loads last)
- Default: 0

**See Also:**
- `.cursor/rules/plugin-eliza-providers.mdc` - Provider implementation patterns
- `.cursor/rules/plugin-eliza-provider-patterns.mdc` - Advanced provider patterns

## Evaluators

**Purpose:** Process and extract information from responses

**Interface:**
```typescript
interface Evaluator {
  name: string;                    // REQUIRED - Unique identifier
  description: string;             // What it evaluates/extracts
  similes?: string[];              // Alternative names
  alwaysRun?: boolean;              // Run on every response
  examples?: EvaluatorExample[];   // Training examples
  validate: (runtime, message, state) => Promise<boolean>;
  handler: (runtime, message, state) => Promise<any>;
}
```

**Core Evaluators (Bootstrap Plugin):**
- reflectionEvaluator - Self-awareness
- factEvaluator - Fact extraction
- goalEvaluator - Goal tracking

**Execution Flow:**
1. Agent generates response
2. `validate()` determines if evaluator should run
3. `handler()` processes and extracts information
4. Extracted data stored in memory

**Common Use Cases:**
- Memory building (extract facts, track preferences)
- Content filtering (remove sensitive data, validate)
- Analytics (track sentiment, measure engagement)

**Rules:**
- ✅ **ALWAYS** run evaluators async (don't block responses)
- ✅ **ALWAYS** store extracted data for future context
- ✅ **ALWAYS** use `alwaysRun: true` sparingly
- ✅ **ALWAYS** provide clear examples for training
- ✅ **ALWAYS** keep handlers lightweight
- ✅ **NEVER** block response generation

## Services

**Purpose:** Manage stateful connections and persistent functionality

**Abstract Class:**
```typescript
abstract class Service {
  static serviceType: string;      // REQUIRED - Service identifier
  capabilityDescription: string;   // What service provides
  protected runtime: IAgentRuntime;
  
  static async start(runtime: IAgentRuntime): Promise<Service>;
  async stop(): Promise<void>;     // Cleanup resources
}
```

**Service Types:**
- TRANSCRIPTION, VIDEO, BROWSER, PDF
- REMOTE_FILES (AWS S3)
- WEB_SEARCH, EMAIL, TEE
- TASK, WALLET, LP_POOL, TOKEN_DATA
- DATABASE_MIGRATION
- PLUGIN_MANAGER, PLUGIN_CONFIGURATION, PLUGIN_USER_INTERACTION

**Service Pattern:**
```typescript
export class MyService extends Service {
  static serviceType = 'my-service';
  capabilityDescription = 'Description of what this service provides';
  
  private client: any;
  private refreshInterval: NodeJS.Timer | null = null;
  
  constructor(protected runtime: IAgentRuntime) {
    super();
  }
  
  static async start(runtime: IAgentRuntime): Promise<MyService> {
    logger.info('Initializing MyService');
    const service = new MyService(runtime);
    await service.initialize();
    return service;
  }
  
  async stop(): Promise<void> {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    if (this.client) {
      await this.client.disconnect();
    }
    logger.info('MyService stopped');
  }
  
  private async initialize(): Promise<void> {
    const apiKey = this.runtime.getSetting('MY_API_KEY');
    if (!apiKey) {
      throw new Error('MY_API_KEY not configured');
    }
    this.client = new MyClient({ apiKey });
    await this.client.connect();
  }
}
```

**Rules:**
- ✅ **ALWAYS** extend Service abstract class
- ✅ **ALWAYS** implement `start()` static method
- ✅ **ALWAYS** implement `stop()` method for cleanup
- ✅ **ALWAYS** handle missing API tokens gracefully
- ✅ **ALWAYS** use delayed initialization for non-critical tasks
- ✅ **ALWAYS** log service lifecycle events
- ✅ **ALWAYS** make services resilient to failures
- ✅ **NEVER** skip cleanup in `stop()`
- ✅ **NEVER** throw errors that crash the service

**Service Lifecycle:**
1. `start()` - Initialize and connect
2. Runtime operation - Provide functionality
3. `stop()` - Cleanup and disconnect

**See Also:**
- `.cursor/rules/plugin-eliza-service-managers.mdc` - Service and manager patterns

## Component Interaction

### Execution Flow

1. **Providers** gather context → compose state
2. **Actions** validate against state → execute if valid
3. **Evaluators** process responses → extract information
4. **Services** provide persistent functionality throughout

### State Composition

```typescript
// Providers contribute to state
const state = await runtime.composeState(message, [
  'RECENT_MESSAGES',
  'CHARACTER',
  'KNOWLEDGE'
]);

// Actions receive composed state
const result = await action.handler(runtime, message, state);

// Evaluators process with full context
await evaluator.handler(runtime, message, state);
```

### Service Access

```typescript
// Actions and providers can access services
const service = runtime.getService<MyService>('my-service');
const data = await service.getData();
```

**Rules:**
- ✅ **ALWAYS** check service availability before use
- ✅ **ALWAYS** use `runtime.getService<T>()` for type safety
- ✅ **ALWAYS** handle service unavailability gracefully
- ✅ **NEVER** assume service exists without checking

## Best Practices

### Actions
- Name actions clearly (VERB_NOUN format)
- Always return ActionResult with `success` field
- Validate before executing
- Return consistent response format
- Use similes for alternative triggers
- Provide diverse examples
- Handle errors gracefully

### Providers
- Return consistent data structures
- Handle errors gracefully
- Cache when appropriate (but not for dynamic)
- Keep data fetching fast
- Document what data is provided
- Use position to control execution order

### Evaluators
- Run evaluators async (don't block responses)
- Store extracted data for future context
- Use `alwaysRun: true` sparingly
- Provide clear examples for training
- Keep handlers lightweight

### Services
- Handle missing API tokens gracefully
- Implement proper cleanup in `stop()`
- Use delayed initialization for non-critical tasks
- Log service lifecycle events
- Make services resilient to failures
- Keep service instances stateless when possible

## Examples

See `.cursor/memory/elizaos-architecture-components.md` for complete examples of:
- Action implementation
- Provider implementation
- Evaluator implementation
- Service implementation
- Component interaction patterns

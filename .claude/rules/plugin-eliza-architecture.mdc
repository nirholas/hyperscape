---
description: ElizaOS plugin architecture - interface, lifecycle, initialization order
globs: packages/plugin-eliza/src/index.ts
alwaysApply: false
---

# Hyperscape Plugin - Architecture

> Plugin architecture, lifecycle, initialization order, and component registration.

## Reference Documentation

- **Plugin Architecture**: https://docs.elizaos.ai/plugins/architecture
- **Plugin Components**: https://docs.elizaos.ai/plugins/components
- **Plugin Development**: https://docs.elizaos.ai/plugins/development
- **Memory**: `.cursor/memory/elizaos-architecture-components.md`

## Plugin Interface

**MANDATORY Structure:**
```typescript
import type { Plugin } from '@elizaos/core';

export const hyperscapePlugin: Plugin = {
  name: '@hyperscape/plugin-eliza',  // REQUIRED - Unique identifier
  description: 'Connect ElizaOS agents to Hyperscape worlds', // REQUIRED
  
  // Core components
  services: [HyperscapeService],      // Persistent connections
  providers: [gameStateProvider, ...], // Context suppliers
  actions: [moveToAction, ...],        // What agent can DO
  evaluators: [],                      // Decision helpers
  
  // Optional components
  init: async (config, runtime) => {  // Initialization logic
    // Validate configuration
    // Set environment variables
  },
  
  events: {                            // Event handlers
    [EventType.RUN_STARTED]: [registerEventHandlers],
  },
  
  dependencies: [],                    // Required plugins
  priority: 0,                         // Loading order
};
```

**Rules:**
- ✅ **ALWAYS** include `name` and `description` (REQUIRED)
- ✅ **ALWAYS** export plugin as named export and default export
- ✅ **ALWAYS** use Zod for configuration validation in `init()`
- ✅ **ALWAYS** handle configuration errors gracefully
- ✅ **NEVER** skip component registration order

## Component Registration Order

**CRITICAL**: Components MUST register in this exact order:

```typescript
// 1. Database adapter (if provided)
if (plugin.adapter) {
  this.registerDatabaseAdapter(plugin.adapter);
}

// 2. Actions ← Hyperscape actions register here
if (plugin.actions) {
  for (const action of plugin.actions) {
    this.registerAction(action);
  }
}

// 3. Evaluators
if (plugin.evaluators) {
  for (const evaluator of plugin.evaluators) {
    this.registerEvaluator(evaluator);
  }
}

// 4. Providers ← Hyperscape providers register here
if (plugin.providers) {
  for (const provider of plugin.providers) {
    this.registerProvider(provider);
  }
}

// 5. Models
if (plugin.models) {
  for (const [modelType, handler] of Object.entries(plugin.models)) {
    this.registerModel(modelType, handler, plugin.name, plugin.priority);
  }
}

// 6. Routes
if (plugin.routes) {
  for (const route of plugin.routes) {
    this.routes.push(route);
  }
}

// 7. Events
if (plugin.events) {
  for (const [eventName, eventHandlers] of Object.entries(plugin.events)) {
    for (const eventHandler of eventHandlers) {
      this.registerEvent(eventName, eventHandler);
    }
  }
}

// 8. Services (delayed if runtime not initialized)
if (plugin.services) {
  for (const service of plugin.services) {
    if (this.isInitialized) {
      await this.registerService(service);
    } else {
      this.servicesInitQueue.add(service);
    }
  }
}
```

**Why Order Matters:**
- Actions may depend on database adapter
- Providers may use actions for context
- Services initialize before components use them
- Breaking order causes initialization failures

**Rules:**
- ✅ **ALWAYS** register components in this exact order
- ✅ **ALWAYS** register services last (they may be delayed)
- ✅ **NEVER** change component registration order
- ✅ **NEVER** assume services are initialized immediately

## Plugin Initialization

### Init Function Pattern

```typescript
async init(config: Record<string, string>, runtime: IAgentRuntime) {
  logger.info('[HyperscapePlugin] Initializing plugin...');
  
  try {
    // Validate configuration with Zod
    const validatedConfig = await configSchema.parseAsync(config);
    
    // Set environment variables from validated config
    for (const [key, value] of Object.entries(validatedConfig)) {
      if (value !== undefined) {
        process.env[key] = String(value);
      }
    }
    
    logger.info('[HyperscapePlugin] Configuration validated');
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errorMessages = error.issues?.map(e => e.message)?.join(', ') || 'Unknown validation error';
      throw new Error(`[HyperscapePlugin] Invalid configuration: ${errorMessages}`);
    }
    throw new Error(`[HyperscapePlugin] Configuration error: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  logger.info('[HyperscapePlugin] Plugin initialized successfully');
}
```

**Rules:**
- ✅ **ALWAYS** validate configuration with Zod schemas
- ✅ **ALWAYS** handle Zod errors gracefully
- ✅ **ALWAYS** set environment variables from validated config
- ✅ **ALWAYS** log initialization steps
- ✅ **NEVER** throw unhandled errors

## Plugin Priority

**Priority System:**
- Higher priority = loads first
- Useful for fundamental services
- Model handlers use priority to determine provider
- Default priority: 0

**Rules:**
- ✅ **ALWAYS** set priority for plugins that need early loading
- ✅ **ALWAYS** use higher priority for database adapters
- ✅ **ALWAYS** use lower priority for dependent plugins
- ✅ **NEVER** create circular dependencies

## Plugin Dependencies

**Dependency Declaration:**
```typescript
export const myPlugin: Plugin = {
  name: 'my-plugin',
  dependencies: ['@elizaos/plugin-sql', '@elizaos/plugin-bootstrap'],
  testDependencies: ['@elizaos/plugin-test-utils'],
};
```

**Rules:**
- ✅ **ALWAYS** declare dependencies explicitly
- ✅ **ALWAYS** ensure dependencies are available
- ✅ **ALWAYS** use testDependencies for test-only plugins
- ✅ **NEVER** create circular dependencies

## Configuration Access

**Three Methods:**

1. **Environment Variables:**
```typescript
const apiKey = runtime.getSetting('MY_API_KEY');
if (!apiKey) {
  throw new Error('MY_API_KEY not configured');
}
```

2. **Config Object:**
```typescript
export const myPlugin: Plugin = {
  config: {
    defaultTimeout: 5000,
    retryAttempts: 3,
  },
};
```

3. **Runtime Settings:**
```typescript
const value = runtime.getSetting('SETTING_NAME');
```

**Rules:**
- ✅ **ALWAYS** use `runtime.getSetting()` for consistent access
- ✅ **ALWAYS** validate configuration in `init()`
- ✅ **ALWAYS** handle missing config gracefully
- ✅ **ALWAYS** document required settings

## Conditional Plugin Loading

**Pattern:** Load plugins based on environment variables

```typescript
const plugins = [
  '@elizaos/plugin-bootstrap', // Always loaded
  ...(process.env.ANTHROPIC_API_KEY ? ['@elizaos/plugin-anthropic'] : []),
  ...(process.env.OPENAI_API_KEY ? ['@elizaos/plugin-openai'] : []),
];
```

**Rules:**
- ✅ **ALWAYS** check environment variables before loading
- ✅ **ALWAYS** provide fallback for missing plugins
- ✅ **ALWAYS** document required environment variables

## Routes

**Route Interface:**
```typescript
interface Route {
  type: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'STATIC';
  path: string;
  filePath?: string;        // For static files
  public?: boolean;         // Public access
  name?: string;            // Route name
  handler?: (req, res, runtime) => Promise<void>;
  isMultipart?: boolean;    // File uploads
}
```

**Rules:**
- ✅ **ALWAYS** define route type explicitly
- ✅ **ALWAYS** handle errors in route handlers
- ✅ **ALWAYS** use runtime parameter for agent access
- ✅ **ALWAYS** set `public: true` for public endpoints

## Event Handlers

**Event Types:**
- World: WORLD_JOINED, WORLD_CONNECTED, WORLD_LEFT
- Entity: ENTITY_JOINED, ENTITY_LEFT, ENTITY_UPDATED
- Room: ROOM_JOINED, ROOM_LEFT
- Message: MESSAGE_RECEIVED, MESSAGE_SENT, MESSAGE_DELETED
- Voice: VOICE_MESSAGE_RECEIVED, VOICE_MESSAGE_SENT
- Run: RUN_STARTED, RUN_ENDED, RUN_TIMEOUT

**Event Handler Pattern:**
```typescript
events: {
  [EventType.RUN_STARTED]: [
    async (payload) => {
      const runtime = payload.runtime;
      const service = runtime.getService<HyperscapeService>('hyperscapeService');
      if (service) {
        registerEventHandlers(runtime, service);
      }
    }
  ],
}
```

**Rules:**
- ✅ **ALWAYS** register event handlers in `events` object
- ✅ **ALWAYS** check service availability in handlers
- ✅ **ALWAYS** handle errors in event handlers
- ✅ **ALWAYS** keep handlers focused and delegate to functions

## Database Adapters

**Pattern:** Provide database adapter for custom storage

```typescript
export const plugin: Plugin = {
  name: '@elizaos/plugin-sql',
  priority: 0,
  init: async (_, runtime) => {
    const dbAdapter = createDatabaseAdapter(config, runtime.agentId);
    runtime.registerDatabaseAdapter(dbAdapter);
  }
};
```

**Rules:**
- ✅ **ALWAYS** register database adapter in `init()`
- ✅ **ALWAYS** use priority 0 for database adapters
- ✅ **ALWAYS** handle database connection errors

## Best Practices Checklist

Before implementing plugin, verify:

- [ ] Plugin has `name` and `description`
- [ ] Components registered in correct order
- [ ] Configuration validated with Zod
- [ ] Environment variables handled gracefully
- [ ] Dependencies declared explicitly
- [ ] Priority set appropriately
- [ ] Event handlers registered correctly
- [ ] Routes defined with proper types
- [ ] Error handling implemented
- [ ] Logging added for debugging

## Forbidden Patterns

❌ **NEVER**:
- Skip component registration order
- Register services before other components
- Skip configuration validation
- Throw unhandled errors in init()
- Create circular dependencies
- Assume services are initialized immediately
- Skip error handling in event handlers

## Required Patterns

✅ **ALWAYS**:
- Register components in correct order
- Validate configuration with Zod
- Handle missing config gracefully
- Declare dependencies explicitly
- Set appropriate priorities
- Register event handlers correctly
- Handle errors gracefully
- Log initialization steps

## Examples

See `.cursor/memory/elizaos-architecture-components.md` for complete examples of:
- Plugin interface structure
- Component registration order
- Initialization patterns
- Configuration handling
- Event handler registration

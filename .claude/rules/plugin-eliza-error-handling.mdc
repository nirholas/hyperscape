---
description: Error handling patterns for Hyperscape plugin - actions, providers, services
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Error Handling Patterns

> Standardized error handling across actions, providers, and services.

## Reference Documentation

- **ElizaOS Patterns**: https://docs.elizaos.ai/plugins/patterns
- **Memory**: `.cursor/memory/elizaos-action-patterns.md`

## Core Principles

1. **Never throw unhandled errors** - Always catch and return proper error structure
2. **Always notify users** - Use callbacks to inform users of errors
3. **Log errors with context** - Include relevant information for debugging
4. **Graceful degradation** - Continue operation when possible
5. **Return proper structures** - Use ActionResult, ProviderResult, or Service error patterns

## Action Error Handling

### Standard Pattern

```typescript
export const myAction: Action = {
  name: 'MY_ACTION',
  handler: async (runtime, message, state, options, callback) => {
    try {
      // Validate service availability
      const service = runtime.getService<HyperscapeService>('hyperscapeService');
      if (!service || !service.isConnected()) {
        await callback?.({
          text: 'Cannot execute action: Hyperscape service not available',
          error: true
        });
        return {
          success: false,
          error: new Error('Hyperscape service not available')
        };
      }

      // Perform action logic
      const result = await performAction(service, message, state);

      // Notify user of success
      await callback?.({
        text: `Action completed: ${result.message}`,
        action: 'MY_ACTION'
      });

      // Return success result
      return {
        success: true,
        text: result.message,
        values: { result: result.data },
        data: { actionResult: result }
      };
    } catch (error) {
      // Log error with context
      runtime.logger.error(`[MY_ACTION] Error:`, {
        error,
        messageId: message.id,
        entityId: message.entityId,
        roomId: message.roomId
      });

      // Notify user of error
      await callback?.({
        text: `Failed to execute action: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error: true
      });

      // Return error result
      return {
        success: false,
        text: `Action failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  }
};
```

**Rules:**
- ✅ **ALWAYS** wrap handler logic in try-catch
- ✅ **ALWAYS** check service availability before use
- ✅ **ALWAYS** notify user via callback on error
- ✅ **ALWAYS** log errors with context (messageId, entityId, roomId)
- ✅ **ALWAYS** return proper ActionResult structure
- ✅ **ALWAYS** convert errors to Error instances
- ✅ **NEVER** throw errors from handlers
- ✅ **NEVER** skip error handling

## Provider Error Handling

### Standard Pattern

```typescript
export const myProvider: Provider = {
  name: 'MY_PROVIDER',
  get: async (runtime, message, state) => {
    try {
      // Attempt to fetch data
      const service = runtime.getService<HyperscapeService>('hyperscapeService');
      if (!service || !service.isConnected()) {
        // Return empty result on service unavailable
        return {
          values: {},
          data: {},
          text: ''
        };
      }

      const data = await fetchProviderData(service, message, state);

      return {
        values: { myData: data.summary },
        data: { myData: data },
        text: `Provider data: ${data.summary}`
      };
    } catch (error) {
      // Log error but don't crash
      runtime.logger.warn(`[MY_PROVIDER] Error fetching data:`, {
        error,
        messageId: message.id
      });

      // Return empty result on error
      return {
        values: {},
        data: {},
        text: ''
      };
    }
  }
};
```

**Rules:**
- ✅ **ALWAYS** handle errors gracefully
- ✅ **ALWAYS** return empty result on error (don't crash)
- ✅ **ALWAYS** log errors with context
- ✅ **ALWAYS** check service availability
- ✅ **NEVER** throw errors from provider get method
- ✅ **NEVER** return null or undefined

## Service Error Handling

### Initialization Errors

```typescript
export class MyService extends Service {
  static serviceType = 'my-service';
  capabilityDescription = 'My service description';

  static async start(runtime: IAgentRuntime): Promise<Service> {
    try {
      const service = new MyService(runtime);
      await service.initialize();
      return service;
    } catch (error) {
      runtime.logger.error(`[MyService] Initialization failed:`, error);
      // Return service instance even if initialization partially failed
      // This allows graceful degradation
      const service = new MyService(runtime);
      service.initialized = false;
      return service;
    }
  }

  private async initialize() {
    const token = this.runtime.getSetting('MY_API_KEY');
    if (!token) {
      this.runtime.logger.warn('[MyService] API key not configured');
      // Don't throw - allow service to exist without full functionality
      return;
    }

    // Initialize with token
    await this.setupClient(token);
  }
}
```

**Rules:**
- ✅ **ALWAYS** handle missing configuration gracefully
- ✅ **ALWAYS** log warnings for missing optional configuration
- ✅ **ALWAYS** allow service to exist with reduced functionality
- ✅ **NEVER** throw errors for missing optional configuration
- ✅ **NEVER** crash on initialization failure

### Connection Errors

```typescript
private async connectWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await this.client.connect();
      this.runtime.logger.info('[MyService] Connected successfully');
      return;
    } catch (error) {
      this.runtime.logger.error(`[MyService] Connection attempt ${i + 1} failed:`, error);

      if (i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        // Final failure - log but don't throw
        this.runtime.logger.error('[MyService] All connection attempts failed');
        // Service continues with reduced functionality
      }
    }
  }
}
```

**Rules:**
- ✅ **ALWAYS** implement retry logic for connections
- ✅ **ALWAYS** use exponential backoff
- ✅ **ALWAYS** log retry attempts
- ✅ **ALWAYS** handle final failure gracefully
- ✅ **NEVER** throw errors from retry logic

### Graceful Shutdown

```typescript
async stop() {
  try {
    // Stop accepting new work
    this.accepting = false;

    // Wait for ongoing work to complete (with timeout)
    await Promise.race([
      this.waitForCompletion(),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Shutdown timeout')), 5000)
      )
    ]).catch(error => {
      this.runtime.logger.warn('[MyService] Shutdown timeout:', error);
    });

    // Close connections
    await this.client?.disconnect().catch(error => {
      this.runtime.logger.warn('[MyService] Error closing connection:', error);
    });

    // Clear timers
    if (this.interval) {
      clearInterval(this.interval);
    }

    // Clear caches
    this.cache?.clear();

    this.runtime.logger.info('[MyService] Stopped gracefully');
  } catch (error) {
    this.runtime.logger.error('[MyService] Error during shutdown:', error);
    // Force cleanup even on error
    this.forceCleanup();
  }
}
```

**Rules:**
- ✅ **ALWAYS** stop accepting new work first
- ✅ **ALWAYS** wait for ongoing work with timeout
- ✅ **ALWAYS** handle cleanup errors gracefully
- ✅ **ALWAYS** force cleanup on shutdown error
- ✅ **NEVER** skip cleanup steps

## Event Handler Error Handling

```typescript
async function handleEvent(payload: EventPayload) {
  try {
    await processEvent(payload);
  } catch (error) {
    // Log error but don't crash
    payload.runtime.logger.error(`[Event] Error in handler:`, {
      error,
      eventType: payload.eventType,
      payload: JSON.stringify(payload).slice(0, 500)
    });

    // Emit error event for monitoring
    await payload.runtime.emit(EventType.SERVICE_ERROR, {
      runtime: payload.runtime,
      error,
      originalEvent: payload
    });

    // Don't throw - allow other handlers to run
  }
}
```

**Rules:**
- ✅ **ALWAYS** handle errors gracefully
- ✅ **ALWAYS** log errors with context
- ✅ **ALWAYS** emit error events for monitoring
- ✅ **NEVER** throw from event handlers
- ✅ **NEVER** crash on handler errors

## Error Types

### Service Unavailable

```typescript
if (!service || !service.isConnected()) {
  return {
    success: false,
    error: new Error('Hyperscape service not available')
  };
}
```

### Validation Errors

```typescript
if (!isValidInput(input)) {
  await callback?.({
    text: 'Invalid input: please check your request',
    error: true
  });
  return {
    success: false,
    error: new Error('Invalid input')
  };
}
```

### Network Errors

```typescript
try {
  await networkCall();
} catch (error) {
  if (error instanceof NetworkError) {
    // Retry logic
    return await retryWithBackoff(networkCall);
  }
  throw error;
}
```

### Timeout Errors

```typescript
const result = await Promise.race([
  slowOperation(),
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Operation timeout')), 5000)
  )
]).catch(error => {
  runtime.logger.warn('[Operation] Timeout:', error);
  return { success: false, error };
});
```

## Logging Patterns

### Error Logging

```typescript
runtime.logger.error(`[Component] Error message:`, {
  error,
  context: {
    messageId: message.id,
    entityId: message.entityId,
    roomId: message.roomId,
    action: 'ACTION_NAME',
    state: state?.values
  }
});
```

### Warning Logging

```typescript
runtime.logger.warn(`[Component] Warning message:`, {
  reason: 'Service not configured',
  fallback: 'Using default behavior'
});
```

### Info Logging

```typescript
runtime.logger.info(`[Component] Info message:`, {
  action: 'ACTION_NAME',
  result: 'success',
  duration: Date.now() - startTime
});
```

**Rules:**
- ✅ **ALWAYS** include component name in log messages
- ✅ **ALWAYS** include relevant context (messageId, entityId, etc.)
- ✅ **ALWAYS** use appropriate log levels (error, warn, info, debug)
- ✅ **ALWAYS** structure log data as objects
- ✅ **NEVER** log sensitive information (API keys, passwords)
- ✅ **NEVER** log excessive data (limit to 500 chars)

## Best Practices Checklist

Before implementing error handling, verify:

- [ ] All async operations wrapped in try-catch
- [ ] Service availability checked before use
- [ ] Users notified via callback on errors
- [ ] Errors logged with context
- [ ] Proper error structures returned
- [ ] Errors converted to Error instances
- [ ] No unhandled errors thrown
- [ ] Graceful degradation implemented
- [ ] Retry logic for transient failures
- [ ] Timeout handling for long operations

## Forbidden Patterns

❌ **NEVER**:
- Throw unhandled errors from handlers
- Skip error handling in async functions
- Return null/undefined on errors
- Log sensitive information
- Skip user notification on errors
- Skip error logging
- Skip service availability checks

## Required Patterns

✅ **ALWAYS**:
- Wrap async operations in try-catch
- Check service availability before use
- Notify users via callback on errors
- Log errors with context
- Return proper error structures
- Convert errors to Error instances
- Handle errors gracefully
- Implement retry logic for connections
- Use timeouts for long operations
- Clean up resources on errors

---
description: ElizaOS plugin development workflow - scaffolding, testing, building
globs: packages/plugin-eliza/**/*
alwaysApply: false
---

# Hyperscape Plugin - Development Workflow

> Plugin development workflow: scaffolding, testing, building, and debugging.

## Reference Documentation

- **Plugin Development**: https://docs.elizaos.ai/plugins/development
- **Plugin Architecture**: https://docs.elizaos.ai/plugins/architecture
- **Plugin Components**: https://docs.elizaos.ai/plugins/components
- **Memory**: `.cursor/memory/elizaos-architecture-components.md`

## Plugin Scaffolding

### Using CLI

**Command:**
```bash
elizaos create my-plugin --type plugin
```

**Two Templates:**

1. **Quick Plugin (Backend Only)**
   - Perfect for: API integrations, blockchain actions, data providers
   - Includes: Basic plugin structure, actions, providers, services
   - No frontend components or UI routes

2. **Full Plugin (with Frontend)**
   - Perfect for: Plugins needing web UI, dashboards, visual components
   - Includes: Everything from Quick Plugin + React frontend, Vite setup, API routes
   - Tailwind CSS pre-configured

**After Scaffolding:**
```bash
cd plugin-my-plugin
bun install              # Dependencies installed automatically
elizaos dev              # Development mode with hot reloading
elizaos start            # Production mode
bun run build            # Build for distribution
```

**Rules:**
- ✅ **ALWAYS** use CLI for new plugins (follows conventions)
- ✅ **ALWAYS** choose appropriate template (Quick vs Full)
- ✅ **ALWAYS** test scaffolded plugin before modifying

## Manual Plugin Creation

**Steps:**

1. **Initialize Project:**
```bash
mkdir plugin-my-custom
cd plugin-my-custom
bun init
```

2. **Install Dependencies:**
```bash
bun add @elizaos/core
bun add -d typescript tsup @types/node
```

3. **Configure TypeScript:** `tsconfig.json`
4. **Configure Build:** `tsup.config.ts`
5. **Create Plugin Structure:** `src/index.ts`
6. **Update package.json** with scripts

**Rules:**
- ✅ **ALWAYS** use Bun as package manager
- ✅ **ALWAYS** configure TypeScript properly
- ✅ **ALWAYS** use tsup for building
- ✅ **ALWAYS** follow plugin structure conventions

## Using Plugins in Projects

### Option 1: Plugin Inside Monorepo

```json
{
  "dependencies": {
    "@yourorg/plugin-myplugin": "workspace:*"
  }
}
```

Then: `bun install` in root directory

### Option 2: Plugin Outside Monorepo

```bash
# In plugin directory
bun install
bun run build
bun link

# In project directory
bun link @yourorg/plugin-myplugin
```

**Rules:**
- ✅ **ALWAYS** rebuild plugin after changes when using `bun link`
- ✅ **ALWAYS** use workspace dependencies in monorepo
- ✅ **ALWAYS** test plugin integration after linking

## Testing

### Test Structure

```
src/
  __tests__/
    test-utils.ts         # Shared utilities and mocks
    index.test.ts         # Main plugin tests
    actions.test.ts       # Action tests
    providers.test.ts     # Provider tests
    evaluators.test.ts    # Evaluator tests
    services.test.ts      # Service tests
```

### Test Utilities

**Create Mock Runtime:**
```typescript
export function createMockRuntime(overrides?: Partial<MockRuntime>): MockRuntime {
  return {
    agentId: 'test-agent-123' as UUID,
    character: { name: 'TestAgent', bio: 'A test agent' },
    getSetting: mock((key: string) => settings[key]),
    useModel: mock(async () => ({ content: 'Mock response' })),
    composeState: mock(async () => ({ values: {}, data: {} })),
    createMemory: mock(async () => ({ id: 'memory-123' })),
    getMemories: mock(async () => []),
    getService: mock(() => null),
    ...overrides,
  };
}
```

**Rules:**
- ✅ **ALWAYS** create test utilities for reusable mocks
- ✅ **ALWAYS** use Bun test framework
- ✅ **ALWAYS** mock external dependencies
- ✅ **ALWAYS** test in isolation

### Testing Actions

**Key Tests:**
- Validation logic (should validate when requirements met)
- Handler execution (should return ActionResult)
- Error handling (should handle errors gracefully)
- Action chaining (should access previous results)
- Examples structure (should have valid example format)

**Rules:**
- ✅ **ALWAYS** test validation logic
- ✅ **ALWAYS** test handler execution
- ✅ **ALWAYS** test error handling
- ✅ **ALWAYS** test examples structure

### Testing Providers

**Key Tests:**
- Return ProviderResult (text, values, data)
- Handle errors gracefully
- Dynamic providers fetch fresh data
- Position ordering works correctly

**Rules:**
- ✅ **ALWAYS** test ProviderResult structure
- ✅ **ALWAYS** test error handling
- ✅ **ALWAYS** test dynamic behavior
- ✅ **ALWAYS** test position ordering

### Testing Services

**Key Tests:**
- Initialize successfully with valid config
- Throw error without required config
- Clean up resources on stop
- Handle missing API tokens gracefully

**Rules:**
- ✅ **ALWAYS** test initialization
- ✅ **ALWAYS** test configuration validation
- ✅ **ALWAYS** test cleanup in `stop()`
- ✅ **ALWAYS** test error handling

### E2E Testing

**Pattern:**
```typescript
export const myPluginE2ETests = {
  name: 'MyPlugin E2E Tests',
  tests: [{
    name: 'should execute full plugin flow',
    fn: async (runtime: IAgentRuntime) => {
      // Create test message
      // Compose state
      // Execute action
      // Verify result
      // Verify side effects
    }
  }]
};
```

**Rules:**
- ✅ **ALWAYS** test full plugin flow
- ✅ **ALWAYS** verify side effects
- ✅ **ALWAYS** test with real runtime
- ✅ **ALWAYS** clean up after tests

### Running Tests

```bash
bun test                    # Run all tests
bun test src/__tests__/actions.test.ts  # Run specific file
bun test --watch            # Watch mode
bun test --coverage         # With coverage
```

**Rules:**
- ✅ **ALWAYS** run tests before committing
- ✅ **ALWAYS** ensure all tests pass
- ✅ **ALWAYS** use watch mode during development
- ✅ **ALWAYS** check coverage

### Test Best Practices

1. **Test in Isolation**: Use mocks to isolate components
2. **Test Happy Path and Errors**: Cover both success and failure cases
3. **Test Validation Logic**: Ensure actions validate correctly
4. **Test Examples**: Verify example structures are valid
5. **Test Side Effects**: Verify database writes, API calls, etc.
6. **Use Descriptive Names**: Make test purposes clear
7. **Keep Tests Fast**: Mock external dependencies
8. **Test Public API**: Focus on what users interact with

## Development Workflow

### Development Mode

```bash
bun run dev              # Watch mode with hot reloading
elizaos dev              # Or with elizaOS CLI
```

**Rules:**
- ✅ **ALWAYS** use development mode during development
- ✅ **ALWAYS** test changes immediately
- ✅ **ALWAYS** check for errors in console

### Building for Production

```bash
bun run build            # Build the plugin
# Output will be in dist/
```

**Rules:**
- ✅ **ALWAYS** build before publishing
- ✅ **ALWAYS** check build output
- ✅ **ALWAYS** verify TypeScript compilation

### Publishing

**To npm:**
```bash
npm login
npm publish --access public
```

**To GitHub Packages:**
```json
{
  "publishConfig": {
    "registry": "https://npm.pkg.github.com"
  }
}
```

**Rules:**
- ✅ **ALWAYS** test plugin before publishing
- ✅ **ALWAYS** update version number
- ✅ **ALWAYS** write changelog
- ✅ **ALWAYS** tag release in git

### Version Management

```bash
npm version patch  # 0.1.0 -> 0.1.1
npm version minor  # 0.1.0 -> 0.2.0
npm version major  # 0.1.0 -> 1.0.0
```

**Rules:**
- ✅ **ALWAYS** follow semantic versioning
- ✅ **ALWAYS** update version before publishing
- ✅ **ALWAYS** commit version changes

## Debugging

### Enable Debug Logging

```typescript
import { logger } from '@elizaos/core';

logger.debug('Plugin initialized', { config });
logger.info('Action executed', { result });
logger.error('Failed to connect', { error });
```

**Rules:**
- ✅ **ALWAYS** use logger instead of console.log
- ✅ **ALWAYS** include context in log messages
- ✅ **ALWAYS** use appropriate log levels

### VS Code Debug Configuration

Create `.vscode/launch.json`:
```json
{
  "version": "0.2.0",
  "configurations": [{
    "type": "node",
    "request": "launch",
    "name": "Debug Plugin",
    "runtimeExecutable": "bun",
    "program": "${workspaceFolder}/src/index.ts",
    "cwd": "${workspaceFolder}",
    "console": "integratedTerminal"
  }]
}
```

**Rules:**
- ✅ **ALWAYS** configure debugger for development
- ✅ **ALWAYS** test debugging setup
- ✅ **ALWAYS** use breakpoints effectively

## Common Issues and Solutions

### Issue: Plugin not loading
**Solution**: Check that plugin is properly exported and added to agent's plugin array

### Issue: TypeScript errors
**Solution**: Ensure `@elizaos/core` is installed and TypeScript is configured correctly

### Issue: Service not available
**Solution**: Verify service is registered in plugin and started properly

### Issue: Tests failing with module errors
**Solution**: Make sure `tsconfig.json` has proper module resolution settings for Bun

**Rules:**
- ✅ **ALWAYS** check plugin export
- ✅ **ALWAYS** verify TypeScript configuration
- ✅ **ALWAYS** check service registration
- ✅ **ALWAYS** verify test configuration

## Best Practices Checklist

Before deploying plugin, verify:

- [ ] Plugin scaffolded or created manually following conventions
- [ ] All dependencies installed
- [ ] TypeScript configured correctly
- [ ] Build configuration set up
- [ ] Tests written and passing
- [ ] Examples included for actions
- [ ] Error handling implemented
- [ ] Logging added for debugging
- [ ] Documentation updated
- [ ] Version number updated

## Examples

See `.cursor/memory/elizaos-architecture-components.md` for complete examples of:
- Plugin scaffolding
- Manual plugin creation
- Test utilities
- Testing patterns
- Development workflow
- Debugging setup
